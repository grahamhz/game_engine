
/* ========================================================================
   File: win32_engine
   Date: 6.15.2016
   Revision: 
   Creator: Graham Zuber 
   Notice: (C) Copyright 2015 by Graham Zuber All Rights Reserved.
   ======================================================================== */

#include <windows.h>
#include <stdint.h>

#define internal static
#define local_persist static 
#define global_variable static 

// how many bytes per pixel
const int bytesPerPixel = 4;

// TODO(graham): should this be global?
global_variable bool running;
global_variable BITMAPINFO bitmapInf;
global_variable void *bitmapMem;
global_variable int bitmapWidth;
global_variable int bitmapHeight;

/*
 * Renders a gradient to the screen.
 * Iterates through the bitmapMem buffer,
 * writing 32 bit pixels.
 */
internal void
Win32RenderGradient(int xOffset, int yOffset)
{
    // init relevant vars
    int pitch = bitmapWidth * bytesPerPixel; // amount to add to move to next row in buffer
    uint8_t *row = (uint8_t *)bitmapMem; // starting point of buffer

    // loop through buffer
    for(int y = 0; y < bitmapHeight; ++y)
    {
	// initialize first pixel of row
	uint32_t *pixel = (uint32_t *)row;
	for(int x = 0; x < bitmapWidth; ++x)
	{
	    /*
	      Pixel in Memory: BB GG RR xx
	      Pixel when Moved Out of Memory: 0x xxRRGGBB
	      Windows was on little endian architecture, but
	      they wanted it to look like RGB in CPU register,
	      so they swapped it.
	    */
	    uint8_t blue = (x + xOffset);
	    uint8_t green = (y + yOffset);
	    *pixel++ = ((green << 8) | blue);
	}

	// move to next row
	row += pitch;
    }
}

/*
 * Creates a new back buffer with the provided width and height.
 * Clears and removes the old back buffer.
 */
internal void
Win32ResizeDIBSection(int width, int height)
{
    // TODO(graham): Bulletproof this.
    // Maybe free after, then free first if that fails.

    // free our old buffer
    if(bitmapMem)
    {
	VirtualFree(bitmapMem, 0, MEM_RELEASE);
    }

    bitmapWidth = width;
    bitmapHeight = height;
    
    // set the info for the buffer that we're going to create
    bitmapInf.bmiHeader.biSize = sizeof(bitmapInf.bmiHeader);
    bitmapInf.bmiHeader.biWidth = bitmapWidth;
    bitmapInf.bmiHeader.biHeight = -bitmapHeight; // negative means it's a top-down representation
    bitmapInf.bmiHeader.biPlanes = 1;
    bitmapInf.bmiHeader.biBitCount = 32;
    bitmapInf.bmiHeader.biCompression = BI_RGB;

    int bitmapMemSize = (bitmapWidth * bitmapHeight) * bytesPerPixel;
    bitmapMem = VirtualAlloc(0, bitmapMemSize, MEM_COMMIT, PAGE_READWRITE);

    Win32RenderGradient(128, 0);
}

/*
 * Stretches the bits in the backbuffer from the dimensions of the previous buffer
 * to the size of the new buffer.
 */
internal void
Win32UpdateWindow(HDC deviceContext, RECT *clientRect, int x, int y, int width, int height)
{
    int windowWidth = clientRect->right - clientRect->left;
    int windowHeight = clientRect->bottom - clientRect->top;
    
    // stretch the back 
    StretchDIBits(
	deviceContext,
/*
	x, y, width, height, // orig rect
	x, y, width, height, // target rect
*/
	0, 0, bitmapWidth, bitmapHeight,
	0, 0, windowWidth, windowHeight,
	bitmapMem,
	&bitmapInf,
	DIB_RGB_COLORS,
	SRCCOPY);
}

/*
 * Main callback for handling window events.
 */
LRESULT CALLBACK
Win32MainWindowCallback(
    _In_ HWND hwnd,
    _In_ UINT uMsg,
    _In_ WPARAM wParam,
    _In_ LPARAM lParam
    )
{
    // default result to success
    LRESULT result = 0;

    // switch on message type
    switch(uMsg)
    {
	case WM_SIZE:
	{
	    RECT clientRect;
	    GetClientRect(hwnd, &clientRect);
	    int width = clientRect.right - clientRect.left;
	    int height = clientRect.bottom - clientRect.top;
	    Win32ResizeDIBSection(width, height);
	    OutputDebugStringA("WM_SIZE\n");
	}
	break;

	case WM_DESTROY:
	{
	    // TODO(graham): should this spawn a message to the user?
	    running = false;
	    OutputDebugStringA("WM_DESTROY\n");
	}
	break;

	case WM_CLOSE:
	{
	    // TODO(graham): should this be handled like an error - respawn window?
	    running = false;
	    OutputDebugStringA("WM_CLOSE\n");
	}
	break;

	case WM_ACTIVATEAPP:
	{
	    OutputDebugStringA("WM_ACTIVATEAPP\n");
	}
	break;

	case WM_PAINT:
	{
	    // TODO(graham): remove this test code
	    PAINTSTRUCT paint;
	    HDC deviceContext = BeginPaint(hwnd, &paint);
	    int x = paint.rcPaint.left;
	    int y = paint.rcPaint.top;
	    int height = paint.rcPaint.bottom - paint.rcPaint.top;
	    int width = paint.rcPaint.right - paint.rcPaint.left;

	    RECT clientRect;
	    GetClientRect(hwnd, &clientRect);
	    Win32UpdateWindow(deviceContext, &clientRect, x, y, width, height);
	    EndPaint(hwnd, &paint);
	    OutputDebugStringA("WM_PAINT\n");
	}
	break;

	default:
	{
//	    OutputDebugStringA("WM DEFAULT\n");
	    result = DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
	break;
    }

    return result;

}

/*
 * Program entry point. Creates and initializes window.
 * Begins intercepting windows messages.
 */
int CALLBACK
WinMain(
    _In_ HINSTANCE hInstance,
    _In_ HINSTANCE hPrevInstance,
    _In_ LPSTR lpCmdLine,
    _In_ int nCmdShow
    )
{
    // set up the window
    WNDCLASS window = {};
    window.style = CS_OWNDC | CS_HREDRAW | CS_VREDRAW;
    window.lpfnWndProc = Win32MainWindowCallback;
    window.hInstance = hInstance;
    window.lpszClassName = "EngineWindowClass";

    if(!RegisterClass(&window))
    {
	// TODO(graham): Log for Debug
	goto Cleanup;
    }

    // create a new window
    HWND windowHandle = CreateWindowEx(
	0,
	window.lpszClassName,
	"Engine",
	WS_OVERLAPPEDWINDOW|WS_VISIBLE,
	CW_USEDEFAULT,
	CW_USEDEFAULT,
	CW_USEDEFAULT,
	CW_USEDEFAULT,
	0,
	0,
	hInstance,
	0);

    if(!windowHandle)
    {
	// TODO(graham): Log for Debug
	goto Cleanup;
    }

    // start running
    running = true;
    
    // get messages
    while(running)
    {
	MSG message;
	while(PeekMessage(&message, 0, 0, 0, PM_REMOVE))
	{
	    if(message.message == WM_QUIT)
	    {
		running = false;
	    }
	    TranslateMessage(&message);
	    DispatchMessage(&message);
	}
    }

Cleanup:
    
    OutputDebugStringA("Fatal Error. Exiting Program.");
    return 0;
}
